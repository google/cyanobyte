// Generated by the Emboss compiler.  DO NOT EDIT!
#ifndef TESTDATA_FLOAT_EMB_H_  
#define TESTDATA_FLOAT_EMB_H_
#include <stdint.h>
#include <string.h>

#include <algorithm>
#include <ostream>
#include <type_traits>
#include <utility>

#include "runtime/cpp/emboss_cpp_util.h"

#include "runtime/cpp/emboss_prelude.h"

namespace emboss {
namespace test {

namespace Floats {

}  // namespace Floats

template <class Storage>
class GenericFloatsView;
namespace Doubles {

}  // namespace Doubles

template <class Storage>
class GenericDoublesView;





namespace Floats {

}  // namespace Floats

template <class View>
struct EmbossReservedInternalIsGenericFloatsView;

template <class Storage>
class GenericFloatsView final {
 public:
  GenericFloatsView() : backing_() {}
  explicit GenericFloatsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  // Views over compatible backing storage should be freely assignable.
  template <typename OtherStorage>
  GenericFloatsView(
      const GenericFloatsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  // Allow pass-through construction of backing_, but only if there is at least
  // one argument, and, if exactly one argument, that argument is not a
  // (possibly c/v/ref-qualified) GenericFloatsView.
  //
  // Explicitly ruling out overloads that might match the copy or move
  // constructor is necessary in order for the copy and move constructors to be
  // reliably found during overload resolution.
  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericFloatsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericFloatsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericFloatsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...)
         {}

  template <typename OtherStorage>
  GenericFloatsView<Storage> &operator=(
      const GenericFloatsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

 

  bool Ok() const {
    if (!IsComplete()) return false;

 
    // If we don't have enough information to determine whether float_little_endian is
    // present in the structure, then structure.Ok() should be false.
    if (!has_float_little_endian.Known()) return false;
    // If float_little_endian is present, but not Ok(), then structure.Ok() should be
    // false.  If float_little_endian is not present, it does not matter whether it is
    // Ok().
    if (has_float_little_endian.ValueOrDefault() && !float_little_endian.Ok()) return false;
 
    // If we don't have enough information to determine whether float_big_endian is
    // present in the structure, then structure.Ok() should be false.
    if (!has_float_big_endian.Known()) return false;
    // If float_big_endian is present, but not Ok(), then structure.Ok() should be
    // false.  If float_big_endian is not present, it does not matter whether it is
    // Ok().
    if (has_float_big_endian.ValueOrDefault() && !float_big_endian.Ok()) return false;

    // If we don't have enough information to determine whether IntrinsicSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_IntrinsicSizeInBytes().Known()) return false;
    // If IntrinsicSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If IntrinsicSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_IntrinsicSizeInBytes().ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;


    // If we don't have enough information to determine whether MaxSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_MaxSizeInBytes().Known()) return false;
    // If MaxSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If MaxSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_MaxSizeInBytes().ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;


    // If we don't have enough information to determine whether MinSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_MinSizeInBytes().Known()) return false;
    // If MinSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If MinSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_MinSizeInBytes().ValueOrDefault() && !MinSizeInBytes().Ok()) return false;

    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericFloatsView<OtherStorage> emboss_reserved_local_other) const {
    
    // If this->float_little_endian() is not equal to emboss_reserved_local_other.float_little_endian(),
    // then the structures are not equal.

    // If either structure's has_float_little_endian() is unknown, then default to not
    // Equals().
    //
    // TODO(bolms): Should Equals() return Maybe<bool> and/or return true for
    // non-Ok()-but-equivalent structures?
    if (!has_float_little_endian().Known()) return false;
    if (!emboss_reserved_local_other.has_float_little_endian().Known()) return false;

    // If one side has float_little_endian() but the other side does not, then the fields
    // are not equal.  We use ValueOrDefault() instead of Value() since Value()
    // is more complex and non-constexpr, and we already know that
    // has_float_little_endian().Known() is true for both structures.
    if (emboss_reserved_local_other.has_float_little_endian().ValueOrDefault() &&
        !has_float_little_endian().ValueOrDefault())
      return false;
    if (has_float_little_endian().ValueOrDefault() &&
        !emboss_reserved_local_other.has_float_little_endian().ValueOrDefault())
      return false;

    // If both sides have float_little_endian(), then check that their Equals() returns
    // true.
    if (emboss_reserved_local_other.has_float_little_endian().ValueOrDefault() &&
        has_float_little_endian().ValueOrDefault() &&
        !float_little_endian().Equals(emboss_reserved_local_other.float_little_endian()))
      return false;
    // If this->float_big_endian() is not equal to emboss_reserved_local_other.float_big_endian(),
    // then the structures are not equal.

    // If either structure's has_float_big_endian() is unknown, then default to not
    // Equals().
    //
    // TODO(bolms): Should Equals() return Maybe<bool> and/or return true for
    // non-Ok()-but-equivalent structures?
    if (!has_float_big_endian().Known()) return false;
    if (!emboss_reserved_local_other.has_float_big_endian().Known()) return false;

    // If one side has float_big_endian() but the other side does not, then the fields
    // are not equal.  We use ValueOrDefault() instead of Value() since Value()
    // is more complex and non-constexpr, and we already know that
    // has_float_big_endian().Known() is true for both structures.
    if (emboss_reserved_local_other.has_float_big_endian().ValueOrDefault() &&
        !has_float_big_endian().ValueOrDefault())
      return false;
    if (has_float_big_endian().ValueOrDefault() &&
        !emboss_reserved_local_other.has_float_big_endian().ValueOrDefault())
      return false;

    // If both sides have float_big_endian(), then check that their Equals() returns
    // true.
    if (emboss_reserved_local_other.has_float_big_endian().ValueOrDefault() &&
        has_float_big_endian().ValueOrDefault() &&
        !float_big_endian().Equals(emboss_reserved_local_other.float_big_endian()))
      return false;

    return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericFloatsView<OtherStorage> emboss_reserved_local_other) const {
    // The contract for UncheckedEquals() is that the caller must assure that
    // both views are Ok() (which implies that has_float_little_endian().Known() is true),
    // and UncheckedEquals() will never perform any assertion checks (which
    // implies that UncheckedEquals() cannot call has_float_little_endian().Value()).

    // If this->has_float_little_endian() but !emboss_reserved_local_other.has_float_little_endian(), or
    // vice versa, then the structures are not equal.  If neither structure
    // has_float_little_endian(), then float_little_endian() is considered equal.
    if (emboss_reserved_local_other.has_float_little_endian().ValueOr(false) &&
        !has_float_little_endian().ValueOr(false))
      return false;
    if (has_float_little_endian().ValueOr(false) &&
        !emboss_reserved_local_other.has_float_little_endian().ValueOr(false))
      return false;

    // If float_little_endian() is present in both structures, then check its equality.
    if (emboss_reserved_local_other.has_float_little_endian().ValueOr(false) &&
        has_float_little_endian().ValueOr(false) &&
        !float_little_endian().UncheckedEquals(emboss_reserved_local_other.float_little_endian()))
      return false;
    // The contract for UncheckedEquals() is that the caller must assure that
    // both views are Ok() (which implies that has_float_big_endian().Known() is true),
    // and UncheckedEquals() will never perform any assertion checks (which
    // implies that UncheckedEquals() cannot call has_float_big_endian().Value()).

    // If this->has_float_big_endian() but !emboss_reserved_local_other.has_float_big_endian(), or
    // vice versa, then the structures are not equal.  If neither structure
    // has_float_big_endian(), then float_big_endian() is considered equal.
    if (emboss_reserved_local_other.has_float_big_endian().ValueOr(false) &&
        !has_float_big_endian().ValueOr(false))
      return false;
    if (has_float_big_endian().ValueOr(false) &&
        !emboss_reserved_local_other.has_float_big_endian().ValueOr(false))
      return false;

    // If float_big_endian() is present in both structures, then check its equality.
    if (emboss_reserved_local_other.has_float_big_endian().ValueOr(false) &&
        has_float_big_endian().ValueOr(false) &&
        !float_big_endian().UncheckedEquals(emboss_reserved_local_other.float_big_endian()))
      return false;

    return true;
  }
  // (Unchecked)CopyFrom copies the number of bytes included in the other view,
  // and ignores the size of the current view.  Even if they differ before
  // copying, the destination view's size should match the source view's size
  // after copying, because any fields used in the calculation of the
  // destination view's size should be updated by the copy.
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericFloatsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericFloatsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericFloatsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;

      // If the field name matches float_little_endian, handle it, otherwise fall
      // through to the next field.
      if (emboss_reserved_local_name == "float_little_endian") {
        // TODO(bolms): How should missing optional fields be handled?
        if (!float_little_endian().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }
      // If the field name matches float_big_endian, handle it, otherwise fall
      // through to the next field.
      if (emboss_reserved_local_name == "float_big_endian") {
        // TODO(bolms): How should missing optional fields be handled?
        if (!float_big_endian().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      // decode_fields will `continue` if it successfully finds a field.
      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;

    if (has_float_little_endian().ValueOr(false)) {
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
      } else {
        if (emboss_reserved_local_wrote_field) {
          emboss_reserved_local_stream->Write(",");
        }
        emboss_reserved_local_stream->Write(" ");
      }
      emboss_reserved_local_stream->Write("float_little_endian: ");
      float_little_endian().WriteToTextStream(emboss_reserved_local_stream,
                                         emboss_reserved_local_field_options);
      emboss_reserved_local_wrote_field = true;
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write("\n");
      }
    }
    if (has_float_big_endian().ValueOr(false)) {
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
      } else {
        if (emboss_reserved_local_wrote_field) {
          emboss_reserved_local_stream->Write(",");
        }
        emboss_reserved_local_stream->Write(" ");
      }
      emboss_reserved_local_stream->Write("float_big_endian: ");
      float_big_endian().WriteToTextStream(emboss_reserved_local_stream,
                                         emboss_reserved_local_field_options);
      emboss_reserved_local_wrote_field = true;
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write("\n");
      }
    }

    // Avoid unused variable warnings for empty structures:
    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }

  typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 float_little_endian() const;
  ::emboss::support::Maybe<bool> has_float_little_endian() const;
  typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 float_big_endian() const;
  ::emboss::support::Maybe<bool> has_float_big_endian() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 private:
  Storage backing_;


  // This is a bit of a hack to handle Equals() and UncheckedEquals() between
  // views with different underlying storage -- otherwise, structs with
  // anonymous members run into access violations.
  //
  // TODO(bolms): Revisit this once the special-case code for anonymous members
  // is replaced by explicit read/write virtual fields in the IR.
  template <class OtherStorage>
  friend class GenericFloatsView;
};
using FloatsView =
    GenericFloatsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using FloatsWriter =
    GenericFloatsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericFloatsView {
  static constexpr bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericFloatsView<
    GenericFloatsView<Storage>> {
  static constexpr bool value = true;
};

template <typename T>
inline GenericFloatsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeFloatsView( T &&emboss_reserved_local_arg) {
  return GenericFloatsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericFloatsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeFloatsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericFloatsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericFloatsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedFloatsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericFloatsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}
namespace Doubles {

}  // namespace Doubles

template <class View>
struct EmbossReservedInternalIsGenericDoublesView;

template <class Storage>
class GenericDoublesView final {
 public:
  GenericDoublesView() : backing_() {}
  explicit GenericDoublesView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  // Views over compatible backing storage should be freely assignable.
  template <typename OtherStorage>
  GenericDoublesView(
      const GenericDoublesView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  // Allow pass-through construction of backing_, but only if there is at least
  // one argument, and, if exactly one argument, that argument is not a
  // (possibly c/v/ref-qualified) GenericDoublesView.
  //
  // Explicitly ruling out overloads that might match the copy or move
  // constructor is necessary in order for the copy and move constructors to be
  // reliably found during overload resolution.
  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericDoublesView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericDoublesView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericDoublesView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...)
         {}

  template <typename OtherStorage>
  GenericDoublesView<Storage> &operator=(
      const GenericDoublesView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

 

  bool Ok() const {
    if (!IsComplete()) return false;

 
    // If we don't have enough information to determine whether double_little_endian is
    // present in the structure, then structure.Ok() should be false.
    if (!has_double_little_endian.Known()) return false;
    // If double_little_endian is present, but not Ok(), then structure.Ok() should be
    // false.  If double_little_endian is not present, it does not matter whether it is
    // Ok().
    if (has_double_little_endian.ValueOrDefault() && !double_little_endian.Ok()) return false;
 
    // If we don't have enough information to determine whether double_big_endian is
    // present in the structure, then structure.Ok() should be false.
    if (!has_double_big_endian.Known()) return false;
    // If double_big_endian is present, but not Ok(), then structure.Ok() should be
    // false.  If double_big_endian is not present, it does not matter whether it is
    // Ok().
    if (has_double_big_endian.ValueOrDefault() && !double_big_endian.Ok()) return false;

    // If we don't have enough information to determine whether IntrinsicSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_IntrinsicSizeInBytes().Known()) return false;
    // If IntrinsicSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If IntrinsicSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_IntrinsicSizeInBytes().ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;


    // If we don't have enough information to determine whether MaxSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_MaxSizeInBytes().Known()) return false;
    // If MaxSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If MaxSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_MaxSizeInBytes().ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;


    // If we don't have enough information to determine whether MinSizeInBytes() is
    // present in the structure, then structure.Ok() should be false.
    if (!has_MinSizeInBytes().Known()) return false;
    // If MinSizeInBytes() is present, but not Ok(), then structure.Ok() should be
    // false.  If MinSizeInBytes() is not present, it does not matter whether it is
    // Ok().
    if (has_MinSizeInBytes().ValueOrDefault() && !MinSizeInBytes().Ok()) return false;

    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericDoublesView<OtherStorage> emboss_reserved_local_other) const {
    
    // If this->double_little_endian() is not equal to emboss_reserved_local_other.double_little_endian(),
    // then the structures are not equal.

    // If either structure's has_double_little_endian() is unknown, then default to not
    // Equals().
    //
    // TODO(bolms): Should Equals() return Maybe<bool> and/or return true for
    // non-Ok()-but-equivalent structures?
    if (!has_double_little_endian().Known()) return false;
    if (!emboss_reserved_local_other.has_double_little_endian().Known()) return false;

    // If one side has double_little_endian() but the other side does not, then the fields
    // are not equal.  We use ValueOrDefault() instead of Value() since Value()
    // is more complex and non-constexpr, and we already know that
    // has_double_little_endian().Known() is true for both structures.
    if (emboss_reserved_local_other.has_double_little_endian().ValueOrDefault() &&
        !has_double_little_endian().ValueOrDefault())
      return false;
    if (has_double_little_endian().ValueOrDefault() &&
        !emboss_reserved_local_other.has_double_little_endian().ValueOrDefault())
      return false;

    // If both sides have double_little_endian(), then check that their Equals() returns
    // true.
    if (emboss_reserved_local_other.has_double_little_endian().ValueOrDefault() &&
        has_double_little_endian().ValueOrDefault() &&
        !double_little_endian().Equals(emboss_reserved_local_other.double_little_endian()))
      return false;
    // If this->double_big_endian() is not equal to emboss_reserved_local_other.double_big_endian(),
    // then the structures are not equal.

    // If either structure's has_double_big_endian() is unknown, then default to not
    // Equals().
    //
    // TODO(bolms): Should Equals() return Maybe<bool> and/or return true for
    // non-Ok()-but-equivalent structures?
    if (!has_double_big_endian().Known()) return false;
    if (!emboss_reserved_local_other.has_double_big_endian().Known()) return false;

    // If one side has double_big_endian() but the other side does not, then the fields
    // are not equal.  We use ValueOrDefault() instead of Value() since Value()
    // is more complex and non-constexpr, and we already know that
    // has_double_big_endian().Known() is true for both structures.
    if (emboss_reserved_local_other.has_double_big_endian().ValueOrDefault() &&
        !has_double_big_endian().ValueOrDefault())
      return false;
    if (has_double_big_endian().ValueOrDefault() &&
        !emboss_reserved_local_other.has_double_big_endian().ValueOrDefault())
      return false;

    // If both sides have double_big_endian(), then check that their Equals() returns
    // true.
    if (emboss_reserved_local_other.has_double_big_endian().ValueOrDefault() &&
        has_double_big_endian().ValueOrDefault() &&
        !double_big_endian().Equals(emboss_reserved_local_other.double_big_endian()))
      return false;

    return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericDoublesView<OtherStorage> emboss_reserved_local_other) const {
    // The contract for UncheckedEquals() is that the caller must assure that
    // both views are Ok() (which implies that has_double_little_endian().Known() is true),
    // and UncheckedEquals() will never perform any assertion checks (which
    // implies that UncheckedEquals() cannot call has_double_little_endian().Value()).

    // If this->has_double_little_endian() but !emboss_reserved_local_other.has_double_little_endian(), or
    // vice versa, then the structures are not equal.  If neither structure
    // has_double_little_endian(), then double_little_endian() is considered equal.
    if (emboss_reserved_local_other.has_double_little_endian().ValueOr(false) &&
        !has_double_little_endian().ValueOr(false))
      return false;
    if (has_double_little_endian().ValueOr(false) &&
        !emboss_reserved_local_other.has_double_little_endian().ValueOr(false))
      return false;

    // If double_little_endian() is present in both structures, then check its equality.
    if (emboss_reserved_local_other.has_double_little_endian().ValueOr(false) &&
        has_double_little_endian().ValueOr(false) &&
        !double_little_endian().UncheckedEquals(emboss_reserved_local_other.double_little_endian()))
      return false;
    // The contract for UncheckedEquals() is that the caller must assure that
    // both views are Ok() (which implies that has_double_big_endian().Known() is true),
    // and UncheckedEquals() will never perform any assertion checks (which
    // implies that UncheckedEquals() cannot call has_double_big_endian().Value()).

    // If this->has_double_big_endian() but !emboss_reserved_local_other.has_double_big_endian(), or
    // vice versa, then the structures are not equal.  If neither structure
    // has_double_big_endian(), then double_big_endian() is considered equal.
    if (emboss_reserved_local_other.has_double_big_endian().ValueOr(false) &&
        !has_double_big_endian().ValueOr(false))
      return false;
    if (has_double_big_endian().ValueOr(false) &&
        !emboss_reserved_local_other.has_double_big_endian().ValueOr(false))
      return false;

    // If double_big_endian() is present in both structures, then check its equality.
    if (emboss_reserved_local_other.has_double_big_endian().ValueOr(false) &&
        has_double_big_endian().ValueOr(false) &&
        !double_big_endian().UncheckedEquals(emboss_reserved_local_other.double_big_endian()))
      return false;

    return true;
  }
  // (Unchecked)CopyFrom copies the number of bytes included in the other view,
  // and ignores the size of the current view.  Even if they differ before
  // copying, the destination view's size should match the source view's size
  // after copying, because any fields used in the calculation of the
  // destination view's size should be updated by the copy.
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericDoublesView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericDoublesView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericDoublesView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;

      // If the field name matches double_little_endian, handle it, otherwise fall
      // through to the next field.
      if (emboss_reserved_local_name == "double_little_endian") {
        // TODO(bolms): How should missing optional fields be handled?
        if (!double_little_endian().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }
      // If the field name matches double_big_endian, handle it, otherwise fall
      // through to the next field.
      if (emboss_reserved_local_name == "double_big_endian") {
        // TODO(bolms): How should missing optional fields be handled?
        if (!double_big_endian().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      // decode_fields will `continue` if it successfully finds a field.
      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;

    if (has_double_little_endian().ValueOr(false)) {
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
      } else {
        if (emboss_reserved_local_wrote_field) {
          emboss_reserved_local_stream->Write(",");
        }
        emboss_reserved_local_stream->Write(" ");
      }
      emboss_reserved_local_stream->Write("double_little_endian: ");
      double_little_endian().WriteToTextStream(emboss_reserved_local_stream,
                                         emboss_reserved_local_field_options);
      emboss_reserved_local_wrote_field = true;
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write("\n");
      }
    }
    if (has_double_big_endian().ValueOr(false)) {
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
      } else {
        if (emboss_reserved_local_wrote_field) {
          emboss_reserved_local_stream->Write(",");
        }
        emboss_reserved_local_stream->Write(" ");
      }
      emboss_reserved_local_stream->Write("double_big_endian: ");
      double_big_endian().WriteToTextStream(emboss_reserved_local_stream,
                                         emboss_reserved_local_field_options);
      emboss_reserved_local_wrote_field = true;
      if (emboss_reserved_local_field_options.multiline()) {
        emboss_reserved_local_stream->Write("\n");
      }
    }

    // Avoid unused variable warnings for empty structures:
    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }

  typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 64>>

 double_little_endian() const;
  ::emboss::support::Maybe<bool> has_double_little_endian() const;
  typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 8>>, 64>>

 double_big_endian() const;
  ::emboss::support::Maybe<bool> has_double_big_endian() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 private:
  Storage backing_;


  // This is a bit of a hack to handle Equals() and UncheckedEquals() between
  // views with different underlying storage -- otherwise, structs with
  // anonymous members run into access violations.
  //
  // TODO(bolms): Revisit this once the special-case code for anonymous members
  // is replaced by explicit read/write virtual fields in the IR.
  template <class OtherStorage>
  friend class GenericDoublesView;
};
using DoublesView =
    GenericDoublesView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using DoublesWriter =
    GenericDoublesView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericDoublesView {
  static constexpr bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericDoublesView<
    GenericDoublesView<Storage>> {
  static constexpr bool value = true;
};

template <typename T>
inline GenericDoublesView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeDoublesView( T &&emboss_reserved_local_arg) {
  return GenericDoublesView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericDoublesView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeDoublesView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericDoublesView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericDoublesView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedDoublesView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericDoublesView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}



namespace Floats {

}  // namespace Floats

template <class Storage>
inline typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericFloatsView<Storage>::float_little_endian()
    const {
  // If it's not possible to read the location of this field, provide a view
  // into a null storage -- the only safe methods to call on it will be Ok() and
  // IsComplete(), but it is necessary to return a view so that client code can
  // call those methods at all.  Similarly, if the end of the field would come
  // before the start, we provide a null storage, though arguably we should
  // not.
  if ( has_float_little_endian().ValueOr(false) && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOr(0) >= 0 && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).ValueOr(0) >= 0) {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
         backing_
            .template GetOffsetStorage<0, 0>(
                ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).ValueOrDefault(), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault()));
  } else {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
  }
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFloatsView<Storage>::has_float_little_endian() const {
  return ::emboss::support::Maybe</**/bool>(true);
}
template <class Storage>
inline typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 GenericFloatsView<Storage>::float_big_endian()
    const {
  // If it's not possible to read the location of this field, provide a view
  // into a null storage -- the only safe methods to call on it will be Ok() and
  // IsComplete(), but it is necessary to return a view so that client code can
  // call those methods at all.  Similarly, if the end of the field would come
  // before the start, we provide a null storage, though arguably we should
  // not.
  if ( has_float_big_endian().ValueOr(false) && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOr(0) >= 0 && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOr(0) >= 0) {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

(
         backing_
            .template GetOffsetStorage<0, 4>(
                ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault(), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault()));
  } else {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

();
  }
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFloatsView<Storage>::has_float_big_endian() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace Floats {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace Floats

template <class Storage>
inline constexpr ::std::int32_t
GenericFloatsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return Floats::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericFloatsView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return Floats::IntrinsicSizeInBytes();
}

namespace Floats {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace Floats

template <class Storage>
inline constexpr ::std::int32_t
GenericFloatsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return Floats::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericFloatsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return Floats::MaxSizeInBytes();
}

namespace Floats {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace Floats

template <class Storage>
inline constexpr ::std::int32_t
GenericFloatsView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return Floats::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericFloatsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return Floats::MinSizeInBytes();
}

namespace Doubles {

}  // namespace Doubles

template <class Storage>
inline typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 64>>

 GenericDoublesView<Storage>::double_little_endian()
    const {
  // If it's not possible to read the location of this field, provide a view
  // into a null storage -- the only safe methods to call on it will be Ok() and
  // IsComplete(), but it is necessary to return a view so that client code can
  // call those methods at all.  Similarly, if the end of the field would come
  // before the start, we provide a null storage, though arguably we should
  // not.
  if ( has_double_little_endian().ValueOr(false) && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOr(0) >= 0 && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).ValueOr(0) >= 0) {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 64>>

(
         backing_
            .template GetOffsetStorage<0, 0>(
                ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)).ValueOrDefault(), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault()));
  } else {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 64>>

();
  }
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericDoublesView<Storage>::has_double_little_endian() const {
  return ::emboss::support::Maybe</**/bool>(true);
}
template <class Storage>
inline typename ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 8>>, 64>>

 GenericDoublesView<Storage>::double_big_endian()
    const {
  // If it's not possible to read the location of this field, provide a view
  // into a null storage -- the only safe methods to call on it will be Ok() and
  // IsComplete(), but it is necessary to return a view so that client code can
  // call those methods at all.  Similarly, if the end of the field would come
  // before the start, we provide a null storage, though arguably we should
  // not.
  if ( has_double_big_endian().ValueOr(false) && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOr(0) >= 0 && ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).Known() &&
      ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOr(0) >= 0) {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 8>>, 64>>

(
         backing_
            .template GetOffsetStorage<0, 8>(
                ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault(), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault()));
  } else {
    return ::emboss::prelude::FloatView<
    /**/ ::emboss::support::FixedSizeViewParameters<64, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::BigEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 8>>, 64>>

();
  }
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericDoublesView<Storage>::has_double_big_endian() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace Doubles {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace Doubles

template <class Storage>
inline constexpr ::std::int32_t
GenericDoublesView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return Doubles::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericDoublesView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return Doubles::IntrinsicSizeInBytes();
}

namespace Doubles {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace Doubles

template <class Storage>
inline constexpr ::std::int32_t
GenericDoublesView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return Doubles::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericDoublesView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return Doubles::MaxSizeInBytes();
}

namespace Doubles {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace Doubles

template <class Storage>
inline constexpr ::std::int32_t
GenericDoublesView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return Doubles::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t GenericDoublesView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return Doubles::MinSizeInBytes();
}






}  // namespace test



}  // namespace emboss




#endif  // TESTDATA_FLOAT_EMB_H_